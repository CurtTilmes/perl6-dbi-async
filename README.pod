=encoding utf-8

=head1 NAME

DBI::Async - Tiny async wrapper around DBIish

=head1 SYNOPSIS

   use DBI::Async;

   # Pass any DBIish.connect() options 
   # connections defaults to 5

   my $db = DBI::Async.new('Pg', connections => 5); 

   # Make blocking requests:

   my $result = $db.query("select version()");
   say $result.row[0];
   $result.finish;

   # Use array() instead of row() to auto-finish the results:

   say $db.query("select version()").array[0];  # array() auto-finishes

   # Use :async to immediately get a Promise:

   my $promise = $db.query("select version()", :async);

   await $promise.then(-> $p
   {
       say $p.result.array[0];
   });

   # Or even start a bunch of background queries in parallel,
   # then check the results

   my @list;

   for 1..10
   {
       @list.push(start {
           say "starting $_";
           my $res = $db.query("select pg_sleep(1)::text, ?::int as val", $_);
           say "Done #", $res.row[1];
           $res.finish;
       });
   }

   await @list;

   $db.dispose; # Drop all queued handles

=head1 DESCRIPTION

Passes all arguments to DBI::Async.new() through to DBIish.connect()
except connections.

Immediately opens $connections database handles.

Each call to query() grabs a free handle, the prepares/executes
the query with that handle.

If no free handles are available, it will queue up the requests and
execute them as handles are finish()ed.

query() returns a DBI::Async::Results object.  It supports the basic
methods from DBIish statement handles:

 .column-names()  # Array of column names
 .column-types()  # Array of column types
 .rows()          # Count of rows returns
 .row()           # Get a single row, call repeatedly to get all
 .allrows()       # Lazy list of all rows suitable for iteration

It has a special version of .finish() that returns the database handle
to the pool to be reused by other queries.  If you access your results
with the methods above, you must explicitly call .finish() to return
the handle.  (Otherwise they will leak and not be available for use
until the garbage collector gets around to reaping them.)

To make this a little easier for common cases, the Results object has
some extra methods that automatically grab the results and finish()
the results for you.

 .array()     # Return a single row as an array
 .hash()      # Return a single row as a hash
 .arrays()    # Eagerly get all rows and return as an array of arrays
 .flatarray() # Flatten all elements of all rows into a single array
 .hashes()    # Eagerly get all rows and return as an array of hashes

If and only if you use those methods to get results, the finish() will
be automatically called.

If you do want to use, e.g. .allrows() to process your results, the
LEAVE phaser or corresponding 'will leave' trait, can assure that the
.finish() gets called, even if the processing code throws an
exception.

These are identical:

 {
     my $res = $db.query(blah blah);
     LEAVE { $res.finish };
     while $res.allrows -> $r {
        ...do something...
     }
 }

or

 {
     my $res will leave { .finish } = $db.query(blah blah);
     while $res.allrows -> $r {
        ...do something...
     }
 }
